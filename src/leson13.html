<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap-grid.min.css">
    <link rel="stylesheet" href="css/bootstrap-reboot.min.css">
    <link rel="stylesheet" href="css/style.min.css">
    <title>Рекурсивные методы</title>
    <style>
        a {
            text-decoration: none;
        }
    </style>
</head>
<body>

    <header>
        <section class="header">
            <div class="container">
                <header id="sidebar">
                    <script src="js/header.js"></script>
                </header>
            </div>
        </section>
   </header>

    <div class="leson13">
        <div class="container">
            <h1>Рекурсивные методы</h1>
            <p>
                Содержание
                <ul>
                    <li><a href="#1">Классический пример рекурсии — вычисление факториала</a></li>
                    <li><a href="#2">Недостатки рекурсивных методов</a>
                        <ul>
                            <li><a href="#2_1">Сложность отладки рекурсивных методов</a></li>
                            <li><a href="#2_2">Попадание в бесконечную рекурсию и переполнение стека</a></li>
                            <li><a href="#2_3">Большее время выполнения по сравнению с обычными методами</a></li>
                        </ul>
                    </li>
                    <li><a href="#3">Итого</a></li>
                </ul>
                Рекурсивный метод — это метод, который вызывает сам себя. Также, в литературе вы можете встретить понятие «рекурсивная функция». Применительно к языку программирования C# эти два понятия равнозначны. Использование рекурсии позволяет сократить исходный код программы и, иногда, сделать его более понятным.
            </p>
            <h3><a name="1">Классический пример рекурсии — вычисление факториала</a></h3>
            <p>
                Вычисление факториала числа — это, видимо, самая популярная задача, решаемая практически всеми студентами на всевозможных языках программирования. Из курса математики мы знаем, что:
                <ol>
                    <li>факториал 0 равен 1</li>
                    <li>факториал 1 равен 1</li>
                    <li>факториал отрицательного числа не существует</li>
                    <li>факториал положительного числа, например, 5 будет равен 1*2*3*4*5 = 120 и записывается как 5! = 1*2*3*4*5 = 120</li>
                </ol>
                Чтобы написать программу, вычисляющую факториал мы можем использовать обычные циклы, а можем написать свой рекурсивный метод:
                <br><br>
                <strong>
                    static int Factorial(int n) <br>
                    { <br>
                        if ((n == 0)||(n==1)) <br>
                            return 1; <br>
                        return n * Factorial(n - 1); <br>
                    } <br><br>
                </strong>
                и, затем, вызвать этот метод в своей программе, например, так:
                <br><br>
                <strong>
                    static void Main(string[] args) <br>
                    { <br>
                        Console.WriteLine(Factorial(5)); <br>
                    } <br><br>
                </strong>
                Что необходимо знать, чтобы рекурсивный метод работал. Во-первых, рекурсивный метод обязательно должен содержать в себе условие выхода из метода. В примере с факториалом — это условие if:
                <br><br>
                <strong>if ((n == 0)||(n==1)) return 1;</strong>
                <br><br>
                как только n станер равной 1 или в метод передадут 0, то работа метода завершается — срабатывает оператор return.  Во-вторых, исходя из определения рекурсивного метода, где-то в методе должен быть вызов самого себя. В нашем случае, вызов осуществляется в этой строке:
                <br><br>
                <strong>return n * Factorial(n - 1);</strong>
                <br><br>
                <img src="img/les13_1.png" alt="1">
                <br><br>
                На каждом шаге выполнения метода до достижения условия выхода из рекурсии в стеке создается запись о вычислении. Как только достигается условие выхода, записи возвращаются из стека и производится окончательное вычисление значения метода. Проверить это можно, запустив приложение и установив точку останова на вызове метода Factorial.
            </p>
            <h3><a name="2">Недостатки рекурсивных методов</a></h3>
            <p>
                Изучая материалы по рекурсивным методам, можно обратить внимание, что практически всегда рассматриваются достоинства таких методов (краткость, легкость восприятия кода и т.д.) и, при этом, достаточно редко акцентируется внимание на недостатках, о которых кто бы и что не говорил, стоит помнить.
                <h5><a name="2_1"></a></h5>
                Рекурсивные методы тяжелее проверять на корректность вычислений, чем обычные методы, например, с циклами. При использовании рекурсии нередко приходится отслеживать и то, что попадает в стек и то, что, в итоге возвращается из стека.
                <h5><a name="2_2"></a>Попадание в бесконечную рекурсию и переполнение стека</h5>
                Как было указано выше, одним из главнейших условий при разработке рекурсивного метода — это наличие условия выхода из метода (или, как ещё говорят — базового сценария). Если рекурсивный метод достаточно большой, то можно упустить этот момент и тогда метод будет вызывать себя до тех пор, пока не произойдет переполнение стека. Например, уберем из нашего метода условие if и попробуем запустить программу. Достаточно быстро вы увидите в консоли вместо решения ошибку вот такого плана:
                <br><br>
                <strong>Stack overflow. <br>
                        Repeat 19280 times:</strong>
                <br><br>
                <h5><a name="2_3">Большее время выполнения по сравнению с обычными методами</a></h5>
                Обычно, на выполнение рекурсивного метода затрачивается большее количество времени, чем на нерекурсивный метод. Например, перепишем вычисление факториала с использованием обычного цикла for:
                <br><br>
                <strong>
                    static long Factorial_2(int n) <br>
                    { <br>
                        if ((n == 0) || (n == 1)) <br>
                            return 1; <br>
                        long result = 1; <br>
                        for (int i = 2; i < n+1; i++) <br>
                            result *= i; <br>
                        return result; <br>
                    } <br><br>
                </strong>
                и теперь сравним скорость работы этих методов, например, на вычислении факториала 20 (результат должен быть равен 2 432 902 008 176 640 000). Ниже представлен результат измерения времени в тактах:
                <br><br>
                <strong>Рекурсия: 71548 <br>
                        Цикл: 1964</strong>
                <br><br>
                Даже на таком простом примере видно, что метод вычисления факториала без рекурсии справился с задачей на порядок быстрее.
            </p>
            <h3><a name="3">Итого</a></h3>
            <p>Рекурсивные методы — это методы, вызывающие сами себя. Рекурсия, в ряде случаев, позволяет сделать ваш код более элегантным, но, при этом, обладает рядом недостатков, в том числе: более медленная скорость выполнения, сложность отладки и возможность получения бесконечной рекурсии. Рекурсивные методы стоит использовать только в том случае, если это действительно необходимо. Там, где есть возможность обойтись без рекурсии — лучше использовать обычные циклы и условные операторы.</p>
        </div>
    </div>
</body>
</html>