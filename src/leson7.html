<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap-grid.min.css">
    <link rel="stylesheet" href="css/bootstrap-reboot.min.css">
    <link rel="stylesheet" href="css/style.min.css">
    <title>Арифметические операторы C#</title>
    <style>
        a {
            text-decoration: none;
        }
    </style>
</head>
<body>

    <header>
        <section class="header">
            <div class="container">
                <header id="sidebar">
                    <script src="js/header.js"></script>
                </header>
            </div>
        </section>
   </header>

    <div class="leson7">
        <div class="container">
            <h1>Арифметические операторы C#</h1>
            <p>
                Содержание
                <ul>
                    <li><a href="#1">Арифметические операторы C#</a>
                        <ul>
                            <li><a href="#1_1">Унарные арифметические операторы C#</a>
                                <ul>
                                    <li><a href="#1_1_1">Операторы приращения (++) и уменьшения (—)</a></li>
                                    <li><a href="#1_1_2">Унарные операторы плюса и минуса</a></li>
                                </ul>
                            </li>
                            <li><a href="#1_2">Бинарные арифметические операторы</a>
                                <ul>
                                    <li><a href="#1_2_1">Умножение (*)</a></li>
                                    <li><a href="#1_2_2">Деление (/)</a></li>
                                    <li><a href="#1_2_3">Остаток от деления (%)</a></li>
                                    <li><a href="#1_2_4">Операторы сложения (+) и вычитания (-)</a></li>
                                    <li><a href="#1_2_5">Операторы составного присваивания</a></li>
                                </ul>
                            </li>
                            <li><a href="#1_3">Приоритет и ассоциативность операторов</a></li>
                        </ul>
                    </li>
                    <li><a href="#2">Итого</a></li>
                </ul>
                При изучении любого языка программирования, будь то Delphi, Python или C#, одной из основных тем изучения на начальном этапе является перечень основных операторов в языке и их применение. Конечно, со временем работать с теми или иными операторами начинаешь, как говориться, «на автомате», но в самом начале пути изучения нового языка эта тема является безусловно одной из основных. Все возможные операторы я, конечно, сейчас рассматривать не буду, но основные всё же стоит рассмотреть, чтобы в дальнейшем не путаться в их применении.
            </p>
            <h3><a name="1">Арифметические операторы C#</a></h3>
            <p>
                Как и в Delphi операторы делятся на две группы: <i>унарные и бинарные</i>.
                <br><br>
                К унарным арифметическим операторам в C# относят:
                <ul>
                    <li>++ (приращение),</li>
                    <li>-- (уменьшение),</li>
                    <li>+ (плюс) и — (минус)</li>
                </ul>
                к бинарным:
                <ul>
                    <li>* (умножение),</li>
                    <li>/ (деление),</li>
                    <li>% (остаток от деления),</li>
                    <li>+ (сложение) и — (вычитание).</li>
                </ul>
                Большинство из этих операторов нам может быть известно из Delphi (кто не знает, как работает умножение или деление в Delphi?), но некоторые из операторов имеют свои особенности в C#. Например, в статье про работу с числами в C# упоминалось что деление 1/3 в C# не вернет нам результат 0,3333 Начнем с унарных.
            </p>
            <h4><a name="1_1">Унарные арифметические операторы C#</a></h4>
            <h5><a name="1_1_1">Операторы приращения (++) и уменьшения (—)</a></h5>
            <p>
                Ближайшими аналогами в Delphi для этих операторов являются процедуры Inc() и Dec().
                <br><br>
                Оператор инкремента ++ увеличивает операнд на 1, а оператор декремента --, соответственно, уменьшает операнд на 1. При этом операндом должна быть переменная, свойство или индексатор.
                <br><br>
                Например, результатом выполнения вот такого кода:
                <br><br>
                <strong>
                    double f = 4.45; <br>
                    int i = 10;  <br>
                    f++;//увеличиваем f на 1  <br>
                    i--;//уменьшаем i на 1  <br>
                    Console.WriteLine("f = {0}, i = {1}",f,i); <br><br>
                </strong>
                будет строка:
                <strong>
                    f = 5,45, i = 9
                </strong>
                <br><br>
                Вроде бы все вполне себе логично — одну переменную увеличили на 1, вторую — уменьшили на 1 и вывели результат в виде строки.
                <br><br>
                «Усложним» пример и напишем следующее:
                <br><br>
                <strong>
                    double f = 4.45; <br>
                    int i = 10; <br>
                    double a = f++; <br>
                    int b = i--;<br>
                    Console.WriteLine("a = {0}, b = {1}", a, b); <br><br>
                </strong>
                Казалось бы, результат измениться не должен и строка должна быть той же, но нет. В результате мы получим:
                <br><br>
                <strong>a = 4,45, b = 10</strong>
                <br><br>
                То есть, переменные а и b получили первоначальные значения f и i. Почему так происходит?
                <br><br>
                Дело в том, что операторы инкремента и декремента в C# поддерживается в двух формах: постфиксной (например, x++) и префиксной (например, ++x).
                <br><br>
                Результатом постфиксного оператора приращения или уменьшения является значение переменной перед выполнением операции, а результатом префиксного оператора, соответственно, значение переменно после выполнения операции.
                <br><br>
                Теперь, если взглянуть на пример выше, становится понятно поведение программы — мы использовали постфиксные операторы и в результате, вначале переменной a присваивается значение f, а уже потом значение переменной f увеличивается на 1. Аналогично происходит и с переменной b — она получает первоначальное значение i и только после этого i уменьшается на 1.
                <br><br>
                На первый взгляд может показаться странным, но вот такое действие:
                <br><br>
                <strong>
                    int i = 0; <br>
                    i = i++; <br><br>
                </strong>
                не поменяет значение переменной i — она также останется равной нулю. Причина такого поведения C# описана выше — использовалась постфиксная форма инкремента.
                <br><br>
                Чтобы наше переменные получили измененные значения код надо переписать с использованием префиксной формы операторов, то есть вот так:
                <br><br>
               <strong>
                    double f = 4.45; <br>
                    int i = 10; <br>
                    double a = ++f; //сначала наращиваем f на 1, а потом - присваиваем значение переменной a <br>
                    int b = --i; <br>
                    Console.WriteLine("a = {0}, b = {1}",a,b);<br><br>
               </strong>
                Результатом выполнения будет строка:
                <br><br>
               <strong> a = 5,45, b = 9</strong>
            </p>
            <h5><a name="1_1_2">Унарные операторы плюса и минуса</a></h5>
            <p>
                Как и в Delphi, унарный оператор + возвращает значение полученного операнда. Унарный оператор - изменяет знак операнда на противоположный. Здесь никаких «подводных камней» нет и результат выполнения следующего кода можно угадать с первого раза:
                <br><br>
                <strong>
                    double f = -4.45; <br>
                    int i = 10; <br>
                    Console.WriteLine("+f = {0}, -i = {1}", +f, -i); <br><br>
                </strong>
                Результатом будет строка:
                <b><br></b>
                <strong>+f = -4,45, -i = -10</strong>
                <br><br>
                Остается только отметить, что целочисленный тип ulong не поддерживает унарный минус. Если мы попытаемся сделать вот так:
                <br><br>
                <strong>
                    ulong i = 10; <br>
                    Console.WriteLine("-i = {0}", -i); <br><br>
                </strong>
                То ещё до компиляции получим ошибку:
                <br><br>
                При этом для целочисленных типов ushort и uint оператор «-» работает.  Вот такой код:
                <br><br>
                <strong>
                    ushort i = 10; //создали переменную <br>
                    Console.WriteLine(i.GetType()); //получили тип данных для i <br>
                    ushort b = i; //присвоили значение i переменной b <br> 
                    Console.WriteLine((-b).GetType()); //получили тип данных для отрицательного значения b <br><br>
                </strong>
                Выведет на экран следующее:
                <br><br>
                <strong>
                    System.UInt16 <br>
                    System.Int32 <br><br>
                </strong>
            </p>
            <h4><a name="1_2">Бинарные арифметические операторы</a></h4>
            <h5><a name="1_2_1"></a></h5>
            <p>
                Оператор умножения * вычисляет произведение операндов, например:
                <br><br>
                <strong>
                    ushort a = 10; //создали переменную <br>
                    int b = 5; //присвоили значение i переменной b <br>
                    Console.WriteLine(a * b); <br><br>
                </strong>
                вернет значение 50, а типом данных для произведения будет, ожидаемо, int. Соответственно, в этом примере:
                <br><br>
                <strong>
                    float a = 10.0f; //создали переменную <br>
                    int b = 5; //присвоили значение i переменной b <br>
                    Console.WriteLine((a * b).GetType()); <br>
                    Console.ReadLine(); <br><br>
                </strong>
                Программа вернет нам вещественный тип float (System.Single).  Другое дело — оператор деления.
            </p>
            <h5><a name="1_2_2">Деление (/)</a></h5>
            <p>
                В C# различают деление целых чисел и деление чисел с плавающей точкой (запятой).
                <br><br>
                Для операндов целочисленных типов (int, short, uint и т.д.) результат оператора / является целочисленным типом, который равен частному двух операндов, округленному в сторону нуля. Собственно об этом мы говорили в заметке про работу с числами в C#.
                <br><br>
                Для типов float, double и decimal результатом оператора / является частное двух операндов. Однако и здесь есть момент, который стоит помнить, а именно: если один из операндов — это decimal, второй операнд не может быть ни float, ни double, так как ни float, ни double не преобразуется неявно в тип decimal. Необходимо явным образом преобразовать операнд float или double в тип decimal (также, про такое поведение C# см. здесь). Вот такой код:
                <br><br>
                <strong>
                    decimal a = 10; <br>
                    double b = 3; <br>
                    Console.WriteLine(a / b); <br><br>
                </strong> 
                Приведет к ошибке.
                <br><br>
                Чтобы код сработал без ошибок надо произвести приведение типов, а именно переписать код следующим образом:
                <br><br>
                <strong>
                    decimal a = 10; <br>
                    double b = 3; <br>
                    Console.WriteLine(a / (decimal)b); <br><br>
                </strong>
                и деление пройдет успешно с результатом
                <br><br>
                <strong>3,3333333333333333333333333333</strong>
            </p>
            <h5><a name="1_2_3"> Остаток от деления (%)</a></h5>
            <p>
                Ближайшим «родственником» в Delphi является оператор mod. Но и здесь у C# есть свои особенности.
                <br><br>
                Для целочисленных операндов результатом a % b является значение полученное из выражения a - (a / b) * b. Знак ненулевого остатка такой же, как и у левого операнда, например:
                <br><br>
                <strong>
                    int a = 10; <br>
                    int b = 3;  <br>
                    Console.WriteLine(a % b); <br><br>
                </strong>
                вернет нам значение 1. Тут всё ровно так же, как и в Delphi. В отличие от Delphi, в C# можно получить остаток от деления вещественных чисел, например:
                <br><br>
                <strong>
                    double a = 10.4; <br>
                    double b = 3.45; <br>
                    Console.WriteLine(a % b); <br><br>  
                </strong>
                Вернет значение
                <br><br>
                <strong>0,0499999999999998</strong>
                <br><br>
                В Delphi с оператором mod такое проделать нельзя. Для получения аналогичного результата нам бы пришлось воспользоваться функцией FMod() из модуля Math.
            </p>
            <h5><a name="1_2_4">Операторы сложения (+) и вычитания (-)</a></h5>
            <p>
                Эти операторы так же, как и везде производят математическое сложение/вычитание правого операнда из левого. Никаких подводных камней и особенностей в этом плане в C# нет.
                <br><br>
                <strong>
                    int a = 10; <br>
                    double b = 3.45; <br>
                    Console.WriteLine(a - b); <br><br>
                </strong>
            вернет
            <br><br>
            <strong>6,55</strong>
            </p>
            <h5><a name="1_2_5">Операторы составного присваивания</a></h5>
            <p>
                В C# имеются также операторы составного присваивания (чего нет в Delphi), которые можно использовать, например, для более короткой записи арифметических операций и в общем случае выглядят следующим образом:
                <br><br>    
                <strong>x op= y</strong>
                <br><br>   
                где op  — какой-либо из рассмотренных выше операторов. Читается такое выражение в развернутом виде следующим образом:
                <br><br>   
                <strong>x = x op y</strong>
                <br><br>   
                Например,
                <br><br>   
                <strong>
                    int a = 10; <br>
                    a += 10; //a=a+10 = 20; <br>
                    Console.WriteLine(a); <br>
                    a /= 10; //a = a/10 = 2; <br>
                    Console.WriteLine(a); <br>
                    a *= 5; //a = a*5 = 10 <br>
                    Console.WriteLine(a); <br>
                    a %= 3; //a = a mod 3 = 1 <br>
                    Console.WriteLine(a);<br><br>  
                </strong> 
                вернет нам значения, которые написаны в комментариях к коду, то есть строки:
                <br><br>   
                <strong>
                    20 <br>
                    2 <br>
                    10 <br>
                    1 
                </strong>
            </p>
            <h4><a name="1_3">Приоритет и ассоциативность операторов</a></h4>
            <p>
                Арифметические операторы выполняются в следующем порядке (по убыванию приоритета):
                <ul>
                    <li>Постфиксный инкремент x++ и декремент x--</li>
                    <li>Префиксный инкремент ++x и декремент --x, унарные операторы + и -</li>
                    <li>Мультипликативные операторы *, /, и %</li>
                    <li>Аддитивные операторы + и -</li>
                </ul>
                Бинарные арифметические операторы имеют левую ассоциативность. То есть операторы с одинаковым приоритетом вычисляются в направлении слева направо.
                <br><br>
                Порядок вычисления, определяемый приоритетом и ассоциативностью операторов, можно изменить с помощью скобок (()).
            </p>
            <h3><a name="2">Итого</a></h3>
            <p>
                Сегодня мы узнали, какие виды арифметических операторов есть в C#, как они работают и в чем их особенности. А также разобрали несколько примеров, показывающих особенности вычисления арифметических выражений в C#.
            </p>
        </div>
    </div>
</body>
</html>