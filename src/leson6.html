<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap-grid.min.css">
    <link rel="stylesheet" href="css/bootstrap-reboot.min.css">
    <link rel="stylesheet" href="css/style.min.css">
    <title>Тонкости работы с числами в C#</title>
    <style>
        a {
            text-decoration: none;
        }
    </style>
</head>
<body>

    <header>
        <section class="header">
            <div class="container">
                <header id="sidebar">
                    <script src="header.js"></script>
                </header>
            </div>
        </section>
   </header>

    <div class="leson6">
        <div class="container">
            <h1>Тонкости работы с числами в C#</h1>
            <p>
                Содержание
                <ul>
                    <li><a href="#1">Работа с целыми числами в C#</a></li>
                    <li><a href="#2">Работа с вещественными числами</a></li>
                    <li><a href="#3">Итого</a></li>
                </ul>
                В обзоре типов данных C# было в том числе было сказано, что от того, какой тип будет иметь наша переменная будет зависеть и то какие максимальные и минимальные значения она сможет принимать. Например, мы не сможем присвоить переменной типа byte значение более 255, так как Visual Studio сразу же сообщит нам, что тип byte такие значения не допускает. В этой части я постараюсь рассмотреть некоторые тонкости работы с целочисленными и вещественными типами данных в C#.
            </p>
            <h3><a name="1">Работа с целыми числами в C#</a></h3>
            <p>
                Как мы уже знаем, в C# есть несколько целочисленных типов данных, которые характеризуются максимально и минимально возможными пределами. Например, переменная типа int может содержать значения от от -2 147 483 648 до 2 147 483 647.  Чтобы узнать пределы, которые может принимать переменная определенного типа можно выполнить вот такие действия:
                <br><br>
                <strong>
                    Console.WriteLine($"Max value = {int.MaxValue}");
                    Console.WriteLine($"Min value = {int.MinValue}");
                </strong>
                <br><br>
                Здесь мы узнаем предельные значения для типа int.
                <br><br>
                Теперь, узнав максимальные и минимальные значения для типа int попробуем выполнить вот такое действие:
                <br><br>
                <strong>
                    int i = int.MaxValue;
                    i = i + 1;
                    Console.WriteLine(i);
                </strong>
                <br><br>
                Вопреки всем ожиданиям, Visual Studio не сделает нам никаких предупреждений, программа скомпилируется и, даже, выдаст нам ответ. Правда не 2 147 483 648, а вот такой:
                <br><br> 
                <strong>-2147483648</strong>
                <br><br>
                Всё дело в том, что если при вычислении значения переменной результат выходит за пределы типа, то возникает условие потери значимости или переполнения. Результат вычисления переменной должен находиться в диапазоне от минимального до максимального значения. Так, в приведенном выше примере мы намеренно получили переполнение и результат оказался равным минимальному значению для int. Соответственно, можно получить обратный результат, например,
                <br><br>
                <strong>
                    int i = int.MinValue;
                    i = i - 2;
                    Console.WriteLine(i);
                </strong>
                <br><br>
                при этом нетрудно догадаться, что значение окажется равным
                <br><br>
                <strong>2147483646</strong>
                <br><br>
                то есть на единицу меньше, чем максимальное значение для типа int. Условия переполнения, в принципе, достаточно просто не допускать при разработке приложений, хотя периодически такие условия и имеют место быть в различных проектах. Теперь посмотрим ещё на один пример:
                <br><br>
                <strong>
                    long longValue = 1000000 * 1000000;
                    Console.WriteLine(longValue);   
                </strong>
                <br><br>
                По логике вещей, тип long в C# должен вполне справиться с задачей так как:
                <br><br>
                <img src="img/les6_1.png" alt="1">
                <br><br>
                Вроде бы мы всё сделали корректно — указали для переменной тип long, но Visual Studio выдает ошибку!
                <br><br>
                Дело в том, что по умолчанию целочисленные литералы воспринимаются как int. Компилятор видит два числа — оба воспринимает как int и результат же ожидает как int, а так как результат вычисления выражения явно выходит за пределы int возникает ошибка. Чтобы этого не происходило можно воспользоваться двумя вариантами:
                <ol>
                    <li>Использовать суффикс L, чтобы показать компилятору, что перед ним число типа long.</li>
                    <li>Завести переменную типа long</li>
                </ol>
                Продемонстрируем оба варианта, которые приведут к тому, что C# правильно вычислит произведение двух чисел:
                <br><br>
                <strong>
                    long longValue = 1000000 * 1000000L;//используем суффикс <br>
                    Console.WriteLine(longValue); <br>
                    long longValue2 = 1000000; <br>
                    Console.WriteLine(longValue2*1000000);//используем переменную типа long <br><br>
                </strong>
                В обоих случаях результат будет верным:
                <br><br>
                1000000000000
                1000000000000
            </p>
           <h3><a name="2"> Работа с вещественными числами</a></h3>
           <p>
            Любой школьник знает, что периодическая десятичная дробь 0.3 не равняется 1/3. Однако, не каждый, кто начинает изучать C# знает, что результатом вот такого действия:
            <br><br>
            <strong>Console.WriteLine(1/3);</strong>
            <br><br>
            будет
            <br><br>
            <strong>0</strong>
            <br><br>
            Здесь, опять же срабатывает правило — целое число (int) делится на целое число (int), следовательно и ответ должен быть int. А так как int не может содержать вещественных чисел, то получаем 0. Выход из сложившейся ситуации точно такое же, как и в предыдущем примере — надо указать компилятору, что хотя бы одно из чисел является вещественным. Для вещественных типов данных в C# можно использовать следующие суффиксы:
            <br><br>
            <img src="img/les6_2.png" alt="2">
            <br><br>
            От того, какой суффикс мы укажем будет зависеть и точность вычисления. Продемонстрировать этом можно с помощью следующего примера:
            <br><br>
            <strong>
                Console.WriteLine($"float: {1 / 3f}");
                Console.WriteLine($"double: {1 / 3d}");
                Console.WriteLine($"decimal: {1 / 3m}");
            </strong>
            <br><br>
            Вывод консоли будет следующим:
            <br><br>
            <strong>
                float: 0,33333334
                double: 0,3333333333333333
                decimal: 0,3333333333333333333333333333
            </strong>
            <br><br>
            как видите, тип float имеет самую низкую точность вычисления. В C# вещественные литералы по умолчанию определяются как double.
            <br><br>
            В одном и том же выражении можно сочетать и целочисленные типы, и типы float и double.  В этом случае целочисленные типы неявно преобразуются в один из типов с плавающей запятой. При необходимости тип float может неявно преобразовываться в double. При этом выражение вычисляется следующим образом:
            <ol>
                <li>Если в выражении есть тип double, оно оценивается как double.</li>
                <li>Если в выражении нет типа double, оно оценивается как float.</li>
            </ol>
            Можно также смешивать целочисленные типы и тип decimal в выражении. В этом случае целочисленные типы неявно преобразуются в тип decimal, а выражение вычисляется как decimal. Однако, тип decimal нельзя смешивать с типами float и double в выражении. В этом случае, если требуется выполнить арифметические операции, операции сравнения или равенства, необходимо явно преобразовать операнды из типа или в тип decimal, например, вот так:
            <br><br>
            <strong>
                double a = 1.0;
                decimal b = 2.1m;
                Console.WriteLine(a + (double)b);
            </strong>
            <br><br>
            Если не производить явное преобразование decimal к double, то Visual Studio также выдаст ошибку:
           </p>
           <h3><a name="3">Итого</a></h3>
           <p>
            В этой части мы рассмотрели некоторые особенности работы с числами в C#. В частности рассмотрели проблемы переполнения при сложении целочисленных значений, узнали как компилятору C# указывать какого типа численный литерал используется и возможности смешивания значений различных типов данных.
           </p>
        </div>
    </div>
</body>
</html>